# def _receiver_loop(self):
#     while self.running:
#         pkt, addr = self.socket.receive_packet()
#         print(pkt.flags)
#         if pkt and addr == self.client_addr:
#             print(f"[RECEIVER LOOP] Received: {pkt}")

#             if len(pkt.payload) > 0:
#                 with self.lock:
#                     seq = pkt.seq_num
#                     if seq >= self.expected_seq:
#                         self.recv_buffer[seq] = pkt.payload
#                         while self.expected_seq in self.recv_buffer:
#                             data = self.recv_buffer.pop(self.expected_seq)
#                             self.expected_seq += len(data)

#                 ack_pkt = Packet(
#                     src_port=self.socket.local_address[1],
#                     dest_port=self.client_addr[1],
#                     seq_num=self.next_seq,
#                     ack_num=self.expected_seq,
#                     flags=ACK
#                 )
#                 print(
#                     f"[RECEIVER LOOP] Sending ACK for payload: {pkt.payload}")
#                 self.socket.send_packet(ack_pkt)

#             elif pkt.flags & ACK:
#                 print(f"[RECEIVER LOOP] Handling ACK {pkt.ack_num}")
#                 self.recv_ack = pkt.ack_num
#                 self.handle_ack(pkt.ack_num)
#                 if self.fin_sent and pkt.ack_num == self.next_seq:
#                     print("[RECEIVER LOOP] Received ACK for our FIN.")
#                     self.got_ack_for_fin.set()

#             elif pkt.flags & FIN:
#                 print("[RECEIVER LOOP] FIN received")

#                 fin_ack = Packet(
#                     src_port=self.socket.local_address[1],
#                     dest_port=self.client_addr[1],
#                     seq_num=self.next_seq,
#                     ack_num=pkt.seq_num + 1,
#                     flags=FIN_ACK
#                 )
#                 self.socket.send_packet(fin_ack)
#                 print("[RECEIVER LOOP] Sent FIN_ACK")

#                 self.got_fin_from_remote.set()

#                 # if not self.fin_sent:
#                 #     print(
#                 #         "[RECEIVER LOOP] Passive FIN triggered (responding to remote close)")
#                 #     threading.Thread(target=self.close,
#                 #                      daemon=True).start()

#                 continue

#             elif pkt.flags & FIN_ACK:
#                 print("[RECEIVER LOOP] Received FIN|ACK")
#                 final_ack = Packet(
#                     src_port=self.socket.local_address[1],
#                     dest_port=self.client_addr[1],
#                     seq_num=self.next_seq,
#                     ack_num=pkt.seq_num + 1,
#                     flags=ACK
#                 )
#                 self.socket.send_packet(final_ack)
#                 print("[RECEIVER LOOP] Sent final ACK")

#                 self.got_fin_from_remote.set()


---------------------------------------

# # چت یک درست
# def _retransmit_loop(self):
#     while self.running:
#         now = time.monotonic()
#         with self.lock:
#             items = list(self.buffer.items())

#         for seq, entry in items:
#             with self.lock:
#                 window_limit = self.send_base + self.window_size * Packet.MSS
#                 if seq >= window_limit or seq < self.send_base or seq not in self.buffer:
#                     continue

#                 ts = entry["timestamp"]
#                 elapsed = now - ts if ts != 0 else float('inf')
#                 if ts == 0 or elapsed > self.timeout:
#                     self.c = True
#                     msg = "Sending new" if ts == 0 else f"Resending, {elapsed:.3f} > {self.timeout}"
#                     print(f"[RETRANSMIT] {msg}: seq {seq}")
#                     entry["timestamp"] = time.monotonic()

#             try:

#                 self.socket.send_packet(entry["packet"])
#                 print(f"a,{self.c},{ts}")
#                 self.c = False
#             except OSError:
#                 pass

#         time.sleep(0.1)

# خودم

# def _retransmit_loop(self):
#     # Give time for ACKs to arrive before checking for timeouts
#     time.sleep(0.5)
#     while self.running:
#         now = time.monotonic()
#         with self.lock:
#             items = list(self.buffer.items())

#         for seq, entry in items:
#             with self.lock:
#                 window_limit = self.send_base + self.window_size * Packet.MSS
#                 if seq >= window_limit or seq < self.send_base:
#                     continue

#                 ts = entry["timestamp"]
#                 if ts == 0:
#                     continue  # hasn't been sent yet

#                 elapsed = now - ts
#                 if elapsed > self.timeout:
#                     print(
#                         f"[RETRANSMIT] Timeout reached: seq={seq}, elapsed={elapsed:.2f}")
#                     entry["timestamp"] = time.monotonic()
#                     try:
#                         self.socket.send_packet(entry["packet"])
#                         print(f"[RETRANSMIT] Packet resent: seq={seq}")
#                     except OSError:
#                         pass

#         time.sleep(0.1)

--------------------------------------------------

# چت
# def handle_ack(self, ack_num):
#     with self.lock:
#         print(
#             f"[ACK-HANDLER] Called with ACK={ack_num}, current send_base={self.send_base}")

#         if ack_num <= self.send_base:
#             # Duplicate ACK
#             self.duplicate_ack_count[ack_num] = self.duplicate_ack_count.get(
#                 ack_num, 0) + 1
#             if self.duplicate_ack_count[ack_num] >= 3:
#                 print(f"[FAST RETRANSMIT] Triggered for seq {ack_num}")
#                 if ack_num in self.buffer:
#                     entry = self.buffer[ack_num]
#                     entry["timestamp"] = time.monotonic()
#                     self.socket.send_packet(entry["packet"])
#         else:
#             # New ACK
#             self.send_base = ack_num
#             self.duplicate_ack_count.clear()

#             # حذف بسته‌هایی که کامل ACK شده‌اند
#             keys_to_delete = [
#                 seq for seq, entry in self.buffer.items()
#                 if seq + len(entry["packet"].payload) <= ack_num
#             ]
#             for seq in keys_to_delete:
#                 del self.buffer[seq]

#             print(f"[ACK] Handling ACK {ack_num}, deleted seq < {ack_num}")
